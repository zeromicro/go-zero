syntax = "v1"

info (
	title:   "filename feature demo"
	desc:    "Demonstrate the necessity of filename annotation"
	version: "1.0"
)

type (
	// Product - Product Resource
	ProductReq {
		ProductId int64 `path:"productId"`
	}
	ProductResp {
		Id          int64   `json:"id"`
		Name        string  `json:"name"`
		Price       float64 `json:"price"`
		Stock       int     `json:"stock"`
		Description string  `json:"description"`
	}
	ProductListReq {
		Page     int `form:"page,default=1"`
		PageSize int `form:"page_size,default=10"`
	}
	ProductListResp {
		List  []ProductResp `json:"list"`
		Total int64         `json:"total"`
	}
	CreateProductReq {
		Name        string  `json:"name"`
		Price       float64 `json:"price"`
		Stock       int     `json:"stock"`
		Description string  `json:"description"`
	}
	UpdateProductReq {
		ProductId   int64   `path:"productId"`
		Name        string  `json:"name,optional"`
		Price       float64 `json:"price,optional"`
		Stock       int     `json:"stock,optional"`
		Description string  `json:"description,optional"`
	}
	DeleteProductReq {
		ProductId int64 `path:"productId"`
	}

	// Order - Order Workflow
	CreateOrderReq {
		ProductId int64 `json:"product_id"`
		Quantity  int   `json:"quantity"`
	}
	OrderResp {
		OrderId   string  `json:"order_id"`
		ProductId int64   `json:"product_id"`
		Quantity  int     `json:"quantity"`
		Amount    float64 `json:"amount"`
		Status    string  `json:"status"`
	}
	PayOrderReq {
		OrderId     string `path:"orderId"`
		PaymentType string `json:"payment_type"` // wechat/alipay/card
	}
	ConfirmOrderReq {
		OrderId string `path:"orderId"`
	}
	CancelOrderReq {
		OrderId string `path:"orderId"`
		Reason  string `json:"reason"`
	}

	// User - User Authentication (fragmentation comparison)
	LoginReq {
		Username string `json:"username"`
		Password string `json:"password"`
	}
	LoginResp {
		Token string `json:"token"`
	}
	RegisterReq {
		Username string `json:"username"`
		Password string `json:"password"`
		Email    string `json:"email"`
	}
	LogoutReq {
		Token string `header:"Authorization"`
	}
	RefreshTokenReq {
		RefreshToken string `json:"refresh_token"`
	}

	// Common Response
	CommonResp {
		Code    int    `json:"code"`
		Message string `json:"message"`
	}
)

// ========================================
// Scenario 1: RESTful Resource - Complete Product CRUD
// Value: All operations for one resource in a single file, following RESTful design principles
// Comparison: Without filename, it generates 5 separate files (get/list/create/update/delete)
// ========================================

@server (
	group:    product
	prefix:   /api/v1/product
	filename: product // All product CRUD operations in one file
)
service demo {
	@doc "Create product"
	@handler createProduct
	post / (CreateProductReq) returns (ProductResp)

	@doc "Get product details"
	@handler getProduct
	get /:productId (ProductReq) returns (ProductResp)

	@doc "Get product list"
	@handler listProducts
	get /list (ProductListReq) returns (ProductListResp)

	@doc "Update product"
	@handler updateProduct
	put /:productId (UpdateProductReq) returns (ProductResp)

	@doc "Delete product"
	@handler deleteProduct
	delete /:productId (DeleteProductReq) returns (CommonResp)
}

// ========================================
// Scenario 2: Business Flow - Order Lifecycle
// Value: Strongly related business steps in one file, easy to understand the complete flow
// Comparison: Without filename, it generates 4 separate files, fragmenting business logic
// ========================================

@server (
	group:    order
	prefix:   /api/v1/order
	filename: order_flow // Complete order flow: create → pay → confirm → cancel
)
service demo {
	@doc "Create order"
	@handler createOrder
	post / (CreateOrderReq) returns (OrderResp)

	@doc "Pay order"
	@handler payOrder
	post /:orderId/pay (PayOrderReq) returns (OrderResp)

	@doc "Confirm order"
	@handler confirmOrder
	post /:orderId/confirm (ConfirmOrderReq) returns (OrderResp)

	@doc "Cancel order"
	@handler cancelOrder
	post /:orderId/cancel (CancelOrderReq) returns (CommonResp)
}

// ========================================
// Scenario 3: Traditional Approach (without filename)
// Comparison: 4 user authentication operations generate 4 separate files
// Problem: Related logic (login/register/logout/refresh) scattered across different files
// ========================================

@server (
	group:  auth
	prefix: /api/v1/auth
	// Note: No filename specified here, will generate 4 separate files:
	// - loginhandler.go
	// - registerhandler.go
	// - logouthandler.go
	// - refreshtokenhandler.go
)
service demo {
	@doc "User login"
	@handler login
	post /login (LoginReq) returns (LoginResp)

	@doc "User registration"
	@handler register
	post /register (RegisterReq) returns (CommonResp)

	@doc "User logout"
	@handler logout
	post /logout (LogoutReq) returns (CommonResp)

	@doc "Refresh token"
	@handler refreshToken
	post /refresh (RefreshTokenReq) returns (LoginResp)
}

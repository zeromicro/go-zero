// Code generated by MockGen. DO NOT EDIT.
// Source: model.go
//
// Generated by this command:
//
//	mockgen -package mon -destination model_mock.go -source model.go monClient monSession
//

// Package mon is a generated GoMock package.
package mon

import (
	context "context"
	reflect "reflect"

	options "go.mongodb.org/mongo-driver/v2/mongo/options"
	gomock "go.uber.org/mock/gomock"
)

// MockmonClient is a mock of monClient interface.
type MockmonClient struct {
	ctrl     *gomock.Controller
	recorder *MockmonClientMockRecorder
	isgomock struct{}
}

// MockmonClientMockRecorder is the mock recorder for MockmonClient.
type MockmonClientMockRecorder struct {
	mock *MockmonClient
}

// NewMockmonClient creates a new mock instance.
func NewMockmonClient(ctrl *gomock.Controller) *MockmonClient {
	mock := &MockmonClient{ctrl: ctrl}
	mock.recorder = &MockmonClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmonClient) EXPECT() *MockmonClientMockRecorder {
	return m.recorder
}

// StartSession mocks base method.
func (m *MockmonClient) StartSession(opts ...options.Lister[options.SessionOptions]) (monSession, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartSession", varargs...)
	ret0, _ := ret[0].(monSession)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartSession indicates an expected call of StartSession.
func (mr *MockmonClientMockRecorder) StartSession(opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartSession", reflect.TypeOf((*MockmonClient)(nil).StartSession), opts...)
}

// MockmonSession is a mock of monSession interface.
type MockmonSession struct {
	ctrl     *gomock.Controller
	recorder *MockmonSessionMockRecorder
	isgomock struct{}
}

// MockmonSessionMockRecorder is the mock recorder for MockmonSession.
type MockmonSessionMockRecorder struct {
	mock *MockmonSession
}

// NewMockmonSession creates a new mock instance.
func NewMockmonSession(ctrl *gomock.Controller) *MockmonSession {
	mock := &MockmonSession{ctrl: ctrl}
	mock.recorder = &MockmonSessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmonSession) EXPECT() *MockmonSessionMockRecorder {
	return m.recorder
}

// AbortTransaction mocks base method.
func (m *MockmonSession) AbortTransaction(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AbortTransaction", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// AbortTransaction indicates an expected call of AbortTransaction.
func (mr *MockmonSessionMockRecorder) AbortTransaction(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AbortTransaction", reflect.TypeOf((*MockmonSession)(nil).AbortTransaction), ctx)
}

// CommitTransaction mocks base method.
func (m *MockmonSession) CommitTransaction(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitTransaction", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// CommitTransaction indicates an expected call of CommitTransaction.
func (mr *MockmonSessionMockRecorder) CommitTransaction(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitTransaction", reflect.TypeOf((*MockmonSession)(nil).CommitTransaction), ctx)
}

// EndSession mocks base method.
func (m *MockmonSession) EndSession(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "EndSession", ctx)
}

// EndSession indicates an expected call of EndSession.
func (mr *MockmonSessionMockRecorder) EndSession(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EndSession", reflect.TypeOf((*MockmonSession)(nil).EndSession), ctx)
}

// WithTransaction mocks base method.
func (m *MockmonSession) WithTransaction(ctx context.Context, fn func(context.Context) (any, error), opts ...options.Lister[options.TransactionOptions]) (any, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, fn}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WithTransaction", varargs...)
	ret0, _ := ret[0].(any)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WithTransaction indicates an expected call of WithTransaction.
func (mr *MockmonSessionMockRecorder) WithTransaction(ctx, fn any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, fn}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTransaction", reflect.TypeOf((*MockmonSession)(nil).WithTransaction), varargs...)
}
